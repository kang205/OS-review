#OS-review

Kwc-Oliver

##Chap.4 存储管理

* 地址转换
    * 地址绑定
        * 编译时刻确定好主存的绝对物理地址
            * MS-DOS的COM文件,无文件头
        * 链接时刻
            * 生成可重定位程序,确定变量的逻辑地址(相对于某个基准,如0)
        * 加载时刻
            * 静态重定位
                *  装入代码时将逻辑地址修改成物理地址,不允许在执行过程中移动位置
            * 动态重定位
                *  对逻辑地址不修改,将分配的主存起始地址装入重定位base寄存器
                *  访存时由硬件完成地址转换
                *  允许程序移动,便于共享(多重定位寄存器),主存利用率高
                *  上下文切换时要保护/恢复重定位寄存器
    *  存储保护
        *  base和limit寄存器维护可访问内存空间(x86没有limit)

* 固定分区
    *  把主存划分成数目固定不变,大小不等的分区
    *  主存分配表,记录起始地址,长度,占用标志
    *  开机分区,共享内存
    *  排队策略
        *  每个分区有单独的队列
            *  调度程序选中作业后将其排入一个能装入它的最小分区的队列尾部
            *  优点,装入分区未用空间最小
            *  缺点,容易出现有的过于空闲有的过于忙碌,负载不均衡
        *  仅维护一个队列
            *  有分区空闲时,从队首搜索第一个能装入的作业/或选择一个能装入的最大的
            *  优点,负载均衡
            *  缺点,浪费空间/不利于比较小的进程
*  可变分区
    *  按照作业大小来划分分区,划分的时间,大小,位置都是动态的
    *  利于资源利用
    *  维护已/未分配分区表(位图),或者采用空闲区链表
* 交换技术
    *  可用于可变分区
    *  为了腾出内存将某些进程(优先级较低,阻塞态,时间片耗尽等)移到磁盘,将磁盘上另一进程加载进内存
    *  分配算法
        *  最先匹配,从头搜索第一个可装入的空闲块(简单快速,使用最多)
        *  下次匹配,从上次找到空闲块的位置向后找
            *  最先匹配的变种,能缩短平均超找时间,存储空间使用更均衡
        *  最佳匹配,遍历全部块,找到能装下的最小块. 性能差,小碎片
        *  最坏匹配,找一个最大的空闲块装入
        *  快速匹配,维护多个大小不同的空闲区链表,每次找能容纳的最小的链表中的第一块即可.归还时,合并相邻块复杂,耗时.
*  覆盖(overlay)技术
    *  内存不足以装入程序时,将程序分段,依次装入覆盖区
    *  需指明可覆盖段,可以无需os支持,由程序员实现
    *  现在极少采用
*  移动技术
    *  可变分区中必须把进程装入一个连续的主存区域
    *  移动占用块使得将减少碎片
    *  移动所有占用块到一端或移动至产生足够大小空闲块即可
    *  开销大,现在不采用

* 分页存储管理
    * 不用于分区管理,允许程序放到不相邻的空闲块中
    * 页目录与页表
        * 页对齐,只需20位描述
        * 页大小4KB,32位地址空间最多2^20页
        * TLB加速页表查询
        * 二级页表
            * 大量页表预先可以不创建,实际使用到的也不多
            * 对页表分页
    * 反置页表
    * 页面置换算法
        * 缺页时没有空闲页需要置换
        * 最优页面替换算法
            * 对每个页用"等待指令数"来评价,也就是替换最晚才用到的页
            * 无法实现,评价标准
        * 最近未使用页面替换算法
            * 最近,上一时钟到现在
            * 第一准则,最近访问过则很可能还会访问
            * 第二准则,修改过则换出时要写回硬盘
            * 按4个优先级,随机选择一个优先级最高被替换的
        * 先进先出(FIFO)页面替换算法
            * 猜想,越早进入主存则越可能少用到(淡出)
        * 第二次机会页面替换算法
            * 跟FIFO一样维护装入时间队列, 当页面被访问时将访问位(即页表中的引用位)置1.替换页面时如果引用位为1则将其置0并置于队列另一端,否则替换之.
        * 最近最少使用(LRU)页面替换算法
            * 考虑淘汰上次访问最久远的页面
            * 硬件LRU(1),维护64位指令计数器,每执行完一条指令+1,将值存到相应的页表的表项中
            * 硬件LRU(2),n*n矩阵(n为page数), 每次访问i页则将i行置1再将i列置零.每行的数字大小即代表访问时间
            * 软件模拟,NFU,aging

* Linux内存管理
	* 物理内存管理器,以页为单位分配
		* 位图与链表相结合
		* 伙伴算法
			* map[i]是一个位图,记录每相邻2^i页的使用情况
			* free[i]是一个空闲链表,记录大小为2^i的空闲页
			* 每次操作对位图取反,目的是加速合并的过程
	* 内核内存管理器
		* 小内存分配,不参与交换
		* slab分配器
			* 主存中建立多个cache对象,每个维护若干个slab对象,每个slab对象由1~32个物理连续的页组成,分成相等大小的内存块
			* 在某个cache中分配内存块就是简单地找到一个不满的slab,分配一个块给他
			* 当所有slab都满时则向物理内存管理器申请新页,当slab中所有块空闲时,可将其归还
	* 虚拟内存管理器
	* 内核虚拟内存管理器
		* 大内存需求
		* 前两者只能分配有限大小或物理上连续的的内存
	* 用户空间内存管理器
		* 该管理器负责进程用户态虚拟内存的动态分配和回收(如C语言中的malloc、free等),它管理的内存在进程的堆中
		* 一般在库中实现,不属于内核
            
* 虚拟存储管理
    * Linux中,用户空间0~3G,系统空间3~4G
    * 进程空间布局
        * text,data,heap,stack,mmap,动态库,环境变量等
    * mm_struct
        * LDT,页目录
        * 每个进程有且仅有一个mm_struct结构,task_struct中有指针指向它
        * mmap是一个vm_area_struct的链表,按地址顺序裂解
        * mmap_avl是维护vm_area_struct的AVL树,在内存区域较多时才建立.在2.6之后用红黑树代替了AVL
    * vm_area_struct
        * 维护一块连续的内存区域,这些区域的并集就是进程有效地虚拟地址空间
        * 可映射到文件,内存空间,io设备等等,由mmap()建立
        * 记录start和end,访问权限
        * vm_file记录指向的文件,可以为空
    * malloc 


