#OS-review

Kwc-Oliver

##Chap.5 IO系统

* IO设备
    * os希望对所有设备提供尽可能一致的接口,设备无关性
    * 块设备
        * 每个数据块有自己的地址
        * 每个块可以独立读写
        * 每次操作可以读多个字节
    * 字符设备
        * 没有寻址操作
        * 每次操作读写一个字节
    * 时钟两者都不是,只定期发出中断
    * 设备控制器
        * 命令寄存器,状态寄存器,数据寄存器
        * 纠错,将比特流转化成块
    * 设备驱动程序
        * 与os,设备有关
        * 内核实现,最好的性能和最坏的可靠性
        * 用户态实现IO操作通过os提供的系统服务实现
    * IO端口
        * 内存映射IO,in/out读写端口,混合方案
        * 混合方案中内存和每个设备都会将地址线和它服务的范围比较
    * IO方式
        * 轮询
        * 中断IO
            * 应用程序请求读操作
            * 驱动上半部分查询状态寄存器,如果忙则驱动等待,直到空闲为止
            * 驱动把命令放入寄存器,启动设备
            * 驱动根据情况保存相应信息到设备状态表,然后挂起
            * 设备完成操作后,控制器中断CPU
            * 中断处理程序确定哪个设备发出的中断,转到相应的处理程序
        * DMA
            *  为了解决连续传输需要多次中断的问题
            *  竞争总线,完成后中断
        * 通道
            * 为了解决复杂IO操作处理
            * 通道程序首地址字CAW
            * 通道状态字CSW,向OS报告情况
            * 结束后中断CPU
* 缓冲技术
    * 硬件缓冲,驱动缓冲
    * 单缓冲,双缓冲,多缓冲
* 磁盘调度
    * 柱面号,磁头号,扇区号
    * 查找时间,移动磁头到柱面,时间较长
    * 搜索时间,旋转指定扇区到磁头下
    * 搜索时间优化
    * 查找时间优化
        * FCFS算法
        * 电梯调度算法
            * 记录移动方向
            * 任务处理优先级:当前柱面,移动方向.如果都没有就改变移动方向
        * 最短查找时间优先算法
            * 先执行查找时间最短的任务
            * 存在饥饿的情况
        * 扫描算法
            * 无脑来回扫
        * 分步扫描算法
            * 将任务分组,每次选一个组扫描
            * 当N很大时,接近于扫描算法.当N=1时,接近于FCFS
        * 循环扫描
            * 从0号柱面到最大号柱面扫描,然后直接返回0号
            * 缩短新来请求的最大延迟
        * 时限调度算法
            * 读/写FIFO队列,电梯排序队列
            * 每个请求有默认的到期时间
            * 当FIFO队列中队首到期时执行此任务
        * 预期调度算法
            * 当一个读请求被分配后,将调度程序执行延迟若干毫秒.
            * 在期间如果程序发出相邻的磁盘读请求,则请求会立即获得服务
            * 否则继续使用时限调度算法
        * 提高磁盘IO速度
            * 提前读
            * 延迟写
            * RAM盘

* RAID
    * 容错性,高性能
    * RAID0
        * 将连续的数据带轮转的写到全部磁盘
        * 交叉读取,提高性能
        * 可靠性差
    * RAID1
        * 磁盘镜像
        * 高可靠性,较好的读取性,较差的写入性
    * RAID2
        * 海明码纠错
        * 平行交叉存取
        * 较好的可靠性和最好的存取时间

* 死锁
    * 定义,如果一个进程集合中的每一个进程都在等待只能由本集合中的其它进程才能引发的事件，那么该组进程是死锁的
    * 处理方法
        * 忽略,鸵鸟算法
        * 检测死锁并恢复
            * 维护资源图,找回路.如果有则撤销一个进程
            * 不维护,周期性检查
        * 谨慎地分配资源,动态避免死锁            
        * 破坏四个条件,预防死锁发生
            * 互斥条件,每一资源要么被分配给了一个进程,要么就是可用的
                * 允许同时使用会引发问题,打印机
                * 假脱机不能解决所有问题.两个进程分别占用了一半缓冲空间则出现死锁.
            * 占有和等待条件,已分配到了一些资源的进程可以请求新的资源
                * 一次性分配资源
                    * 难以预测,不够优化
                * 请求资源是先暂时释放当前占用的所有资源,再一次性获取
            * 不可抢占条件。已分配给一个进程的资源不能强制性地被抢占,只能被占有它的进程显式地释放。
                * 很多设备不能被强占
            * 环路等待条件。死锁发生时，系统中必然有一条由两个或两个以上的进程组成的环路（请求资源进程到拥有资源进程构成一个有向边），即该环路中的每一个进程都在等待环路中下一个进程占用的资源。
                * 要求每一进程同时只占用一个资源,不可接受
                * 资源太多,潜在资源,无法编号


