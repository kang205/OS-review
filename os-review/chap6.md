#OS-review

Kwc-Oliver

##Chap.6 文件系统

* Ext2
    * 块组表
        * 将磁盘分成若干组,每块有独立的super block
        * 用块组表描述本块信息
        * 每个块都存有所有块组表描述符
    * inode
        * 描述了一个文件的所有信息
        * 用索引的方式指向存放数据block块
        * 还有一/二/三次间接,即指向一个用于索引的block,再指向数据块或者其他用于索引的block
    * dentry
        * 描述了目录结构,文件名到inode的映射
        * subdirs和child刻画树结构,左儿子右兄弟
    * 查找文件过程
        * 从进程的根目录项得到inode编号
        * 根据inode编号和超级快的inodes_per_group算出所在块组
        * 找到描述根目录文件的inode,读取i_block(目录项列表)
        * 所有对应文件名的项,得到inode编号
        * 重复以上过程,当找到文件时返回改inode
    * 文件描述符->deentry->inode
* Ext3
    * 元数据
    * journal inode
    * 日志文件,增量修改,记录操作,方便恢复
    * 周期在检查点释放不用的旧块


* FAT
    * 12/16位簇标识符,每个簇大小512B~8KB.最大32MB/4GB
    * 两份文件分配表
    * 目录项的26~27字节维护首簇号,如果只占用一个则为FFFF表示结束,否则为下一个簇号
    * FAT32长文件名
* NTFS
    * 原子性事务
    * 安全性
        * 安全描述符, 标识身份的口令
    * 多数据流
    * Unicode,索引,动态坏簇重映射,日志&增量备份,加密
    * LCN,VCN
    * 主文件表MFT
        * 每个记录1KB,将位图,目录,引导程序都视作文件
        * 如果一个文件有很多属性,第一个MFT(基本文件记录)存储了其他MFT记录的位置
        * 特殊(前几)项
            * MFT文件自己,镜像,日志文件,根目录,安全文件引导,坏簇等
        * 文件引用号,序列号+文件号
        * 驻留/非驻留属性,属性存在MFT或行串(VCN-LCN映射)中
        * 目录→文件名索引→文件引用→文件, B+树
        * $SDH将安全描述符的散列值映射到安全描述符,$SII将安全ID映射到安全描述符
    * 可恢复性
        * 其他
            * 谨慎写
                * 顺序执行子操作,避免出现破坏数据
            * 延迟写
                * 性能高,不一致
        * 日志系统+延迟写
        * 确保卷结构不会破坏
        * 日志文件服务LFS
            * 重启动去,日志文件记录
            * 恢复过程
                * 向前读取,重新完成记录在日志中但没来得及刷新到磁盘的事务
                * 向后读取,撤销或回滚崩溃之前没完全记录下来的事务
                * 设置更高的LSN
        * 日志记录类型
            * 更新记录
                * redo信息,描述如何将子操作重新应用到磁盘
                * undo信息,描述如何逆转未记录完全事务的子操作
            * 检查点
                *  每隔5s写入检查点,包含事务表/脏页表,记录LSN在重启动区
                *  分析扫描
                *  redo扫描
                *  undo扫描
                *  恢复到之前某一个一致状态


* 文件系统缓存
    * inode
        * VFS inode全局唯一,可以共享
        * 建立hash表,hash值根据文件系统超级块和inode编号计算.优先查找缓存再去磁盘找
        * VFS自己管理inode结构的分配和回收
            * 维护正在使用的inode hash表
            * 维护3个队列
                * unused,当前空闲的inode
                * in_use,正在被使用但未被修改的
                * s_dirty,脏inode,由in_use转移过来
            * 申请物理页分割成成inod,加入ununsed链表
            * 将引用计数为0的inode重用,注意脏写回和锁定
    * dentry
        * 建立hash表,hash值由它的父目录项和它自己的名字决定
        * dentry_unsed队列
    * buffer
        * 一个数据块对应一个buffer,可以共享
        * 对块设备读写请求先经过buffer,找不到再用驱动程序
        * buffer_head和数据缓冲区
        * 每个buffer用设备标示符和它的块编号唯一标识
        * 空闲buffer向量表free_list
            * 按大小分成队列
            * 需要时查找大小相等的buffer,没有的话申请新页
        * 使用buffer向量表lru_list
            * BUF_CLEAN,未使用的，新的buffer
            * BUF_LOCKED,锁定的,正在进行I/O操作的buffer
            * BUF_DIRTY,包含新的有效的数据,将要被写到但还没有被写到块设备上的buffer
        * 从buf_clean回收到free_list
        * reuse_list和unsed_list
